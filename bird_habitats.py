import os
import sys
sys.path.append(os.path.dirname(sys.path[0]))

from habitats import RedList, HabitatGenerator, reproject_shapefile
from scgt import GeoTiff


def generate_habitats(species_list_path, terrain_path, output_folder, terrain_codes_path=None,
                        bounds=None, crs=None, resolution=None, resampling="near", padding=200000,
                        refine_method="forest_add308", reproject_inputs=False, species_range_folder=None):
    """
    :param species_list_path: Path to txt file of the bird species, with 6-letter eBird species codes on individual lines
    :param terrain_path: Path to terrain raster
    :param output_folder: Folder to place habitat output files and terrain-to-resistance csv files in
    :param terrain_codes_path: Path to a CSV containing terrain resistance codes. If not generated, it can be generated by setting reproject_inputs to True
    :param bounds: (xmin/left, ymin/bottom, xmax/right, ymax/top) bounds to crop habitats to and padding in units of chosen CRS, None if you don't want to crop
    :param crs: Chosen CRS to reproject all input files to, as an ESRI WKT string
    :param resolution: Resolution in the units of the chosen CRS. Set to None to just use the current resolution of the terrain raster
    :param resampling: Type of resampling to use when reprojecting the input tiffs; see https://gdal.org/programs/gdalwarp.html#cmdoption-gdalwarp-r for valid arguments
    :param padding: padding in units of chosen CRS to add around the bounds
    :param refine_method: What terrain should be considered as good habitat: "forest", "forest_add308", "allsuitable", "majoronly"
    :param reproject_inputs: Set True to produce new terrain file with provided resolution/resampling/CRS setting and terrain_codes_path file
    :param species_range_folder: For specifying custom shapefile range inputs for species. Not implemented yet
    """
    
    if crs is None:
        crs = 'PROJCS["Albers_Conical_Equal_Area",GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]],PROJECTION["Albers_Conic_Equal_Area"],PARAMETER["latitude_of_center",23],PARAMETER["longitude_of_center",-96],PARAMETER["standard_parallel_1",29.5],PARAMETER["standard_parallel_2",45.5],PARAMETER["false_easting",0],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH]]'

    # if reproject_inputs, we generate new terrain_codes CSV in the output folder
    if reproject_inputs:
        terrain_codes_path = output_folder

    # Check for valid inputs
    assert os.path.isfile(terrain_path), "invalid terrain_path"
    assert os.path.isfile(species_list_path), "invalid species_list_path"
    assert os.path.isdir(output_folder), f"output_folder {output_folder} is not a valid directory"

    if reproject_inputs:
        assert os.path.isdir(os.path.dirname(terrain_codes_path)), f"terrain_codes_path {terrain_codes_path} is not a directory. \
            Either set reproject_inputs to False to not generate new terrain_codes_path, or provide a directory for terrain_codes_path"
    else:
        assert os.path.isfile(terrain_codes_path), f"terrain_codes_path {terrain_codes_path} does not exist; set reproject_inputs to True to generate"

    assert resolution == None or isinstance(resolution, int), "invalid resolution"
    assert resampling in ["near", "bilinear", "cubic", "cubicspline", "lanczos", "average", "rms", "mode", "max", "min", "med", "q1", "q3", "sum"], \
                f"{resampling} is not a valid resampling value. See https://gdal.org/programs/gdalwarp.html#cmdoption-gdalwarp-r for valid arguments"

    if species_range_folder is None:
        # Specify eBird range file locations if no input ranges folder is specified
        species_range_folder = os.path.join(output_folder, "ebird_ranges")
        if not os.path.exists(species_range_folder):
            os.makedirs(species_range_folder)
        indiv_range_path = os.path.join(species_range_folder, "/2020/{code}/ranges/{code}_range_smooth_mr_2020.gpkg")
        indiv_range_layer = "range"
    else:
        # If given by user instead, assume the range paths by speches from given folder.
        # Should change later
        assert os.path.isdir(species_range_folder), "invalid species_range_folder"
        indiv_range_path = os.path.join(species_range_folder, "/{code}/range.gpkg")
        indiv_range_layer = "range"

    # Get the list of bird species from species_list_path
    with open(species_list_path) as file:
        species_list = file.read().splitlines()

    terrain_path = os.path.abspath(terrain_path)
    terrain_codes_path = os.path.abspath(terrain_codes_path)

    # Generate species output folders
    for species in species_list:
        species_output_folder = os.path.join(output_folder, species)
        if not os.path.exists(species_output_folder):
            os.makedirs(species_output_folder)

    # Create species output folder if it doesn't currently exist
    if not os.path.exists(species_output_folder):
        os.makedirs(species_output_folder)

    redlist = RedList()
    habitat_generator = HabitatGenerator(
        terrain_path=terrain_path,
        terrain_codes_path=terrain_codes_path,
        crs=crs,
        resolution=resolution,
        resampling=resampling,
    )

    # If reproject_inputs, reproject and crop the input terrain.

    if reproject_inputs:
        habitat_generator.reproject_terrain()
        # Crop terrain if bounds are specified
        if bounds is not None:
            habitat_generator.crop_terrain(bounds=bounds, padding=padding)
        habitat_generator.write_map_codes()
        # Once it's done once, don't do it again
        reproject_inputs = False

    # Obtain species habitat information from the IUCN Red List.

    species_data = []

    for species in species_list:
        sci_name = redlist.get_scientific_name(species)
        # When eBird's scientific name differs from that on Red List, we manually correct it here
        if species == "whhwoo":
            sci_name = "Leuconotopicus albolarvatus"
        if species == "yebmag":
            sci_name = "Pica nutalli"
            
        habs = redlist.get_habitats(sci_name)

        # report if ebird scientific name didn't map to IUCN name
        if len(habs) == 0:
            print(f"{species} info could not be found on IUCN Red List due to an uncaught name \
                    mismatch with eBird. Please report to Ecoscape for assistance")
            continue
        
        data = {
            "name": species,
            "sci_name": sci_name,
            "habitats": habs
        }
        species_data.append(data)

    # Download species ranges as shapefiles from eBird.
    if species_range_folder:
        habitat_generator.get_ranges_from_ebird(species_list_path, species_range_folder)

    # Create the resistance table for each species.
    all_map_codes = habitat_generator.get_map_codes()
    for species in species_data:
        code = species["name"]
        resistance_output_path = os.path.join(output_folder, code, "resistance.csv")
        habitat_generator.generate_resistance_table(species, resistance_output_path, all_map_codes)

    # Perform the intersection between the range and habitable terrain.
    with GeoTiff.from_file(habitat_generator.terrain_path) as ter:
        # In case resolution was initially marked as None
        resolution = int(ter.dataset.transform[0])
        
        for i, species in enumerate(species_data):
            if not os.path.isfile(indiv_range_path.format(code=species["name"])):
                print("{num}. Skipping {code}, no associated indiv_range_path found".format(num=i+1, code=species["name"]))
                continue

            print("{num}. Refining {code}".format(num=i+1, code=species["name"]))

            code = species["name"]

            # Load the range shapes for the given species, and put them into the correct CRS
            range_shapes = reproject_shapefile(
                shapes_path=indiv_range_path.format(code=code),
                dest_crs=crs,
                shapes_layer=indiv_range_layer
            )

            # Depending on the length of range_shapes, determine if this is a seasonal bird.
            if len(range_shapes) == 1:
                # Not a seasonal bird
                path = os.path.join(output_folder, code, f"habitat_2020_{resolution}_{resampling}_{refine_method}.tif")
                habitat_generator.refine_habitat(ter=ter, species=species, shapes=range_shapes[0], output_path=path, refine_method=refine_method)
            else:
                # Seasonal bird, different output for each shape
                for s in range_shapes:
                    season = str(s["properties"]["season"])
                    path = os.path.join(output_folder, code, f"{season}_habitat_2020_{resolution}_{resampling}_{refine_method}.tif")
                    habitat_generator.refine_habitat(ter=ter, species=species, shapes=s, output_path=path, refine_method=refine_method)